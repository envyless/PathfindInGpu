#include "Assets/CommonUtils/Compute/CommonCS.compute"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


struct PathInfo
{
    bool IsNotPathAble;
    int Index;

    //position
    float2 position;
    float CostToGoal;    
};

struct CalculatePathInfo
{
    int Index;
    float Cost;
    
    float GetSize()
    {
        return 0;
    }
};

ArrayStruct(CaculatedList,CalculatePathInfo,100);

// contains all of path info ordered index
RWStructuredBuffer<PathInfo> PathBuffer;
// need calcuate that index
RWStructuredBuffer<CalculatePathInfo> CalcPathBuffer;
int NumWidth;
int NumHeight;
int PlayerIndex, GoalIndex;
float2 PlayerPosition, GoalPosition;

uint GetIndex(uint3 id)
{    
    //PathBuffer[id.x].CostToGoal = cc.index;
	return id.x; //+ id.y * NumWidth;
}

float GetCostToGoal(uint from_index, uint goal_index)
{
    PathInfo pathInfoFrom = PathBuffer[from_index];
    //check able to go?
    if(pathInfoFrom.IsNotPathAble)
        return -1;
    
    PathInfo pathInfoGoal = PathBuffer[goal_index];
    float2 toLen = pathInfoGoal.position - pathInfoFrom.position;
    float doubled_len = toLen.x * toLen.x + toLen.y * toLen.y;
    
    return doubled_len; 
}

void CalcPath(inout CalculatePathInfo ceap_path_info, inout CaculatedList openList, int index_from, int index_to)
{   
    openList.index = 0;
    CalculatePathInfo from_calc_path;
    from_calc_path.Index = index_from;
    from_calc_path.Cost = GetCostToGoal(index_from, GoalIndex);
    openList.Add(from_calc_path);
    if(ceap_path_info.Cost > openList.Last().Cost)
        ceap_path_info = openList.Last(); 
}

void PathFind(int index)
{
    CaculatedList openList;  
    
    for(int i = 0; i < 100; ++i){
        openList.buffer[i].Cost = 0;
        openList.buffer[i].Index = 0;
    }
      
    //list index    
    //temp buffer
    openList.MaxCount = 100;
    openList.index = 0;
    
    CaculatedList closeList;  
    closeList.index = 0;  
    
    int path[100];
    int current_index = 0;
    bool isFind = false;        
    
    PathInfo pathInfo = PathBuffer[index];
    CalculatePathInfo ceap_path_info;
    ceap_path_info.Index = 0;
    ceap_path_info.Cost = 10000;
    if(index == GoalIndex)
        return;
                 
    while(!isFind)
    {
        if(current_index >= 100)
            break;   
        current_index++;                                   
                
        int indexY = index / NumWidth;
        int indexX = index % NumWidth;
        
              
        int up_index = index + NumWidth;
        if(indexY + 1 < NumHeight)
        {        
            CalcPath(ceap_path_info, openList, up_index, GoalIndex);                                          
        }
        openList.index++;
            
        int down_index = index - NumWidth;
        //down check
        if(indexY - 1 >= 0)
        {
            CalcPath(ceap_path_info, openList, down_index, GoalIndex);   
        }    
        openList.index++;
        
        int left = index - 1;
        //left check
        if(indexX - 1 > 0)
        {
            CalcPath(ceap_path_info, openList, left, GoalIndex);    
        }    
        openList.index++;
        
        int right = index + 1;
        if(indexX + 1 < right)
        {
            CalcPath(ceap_path_info, openList, right, GoalIndex);   
        }    
        openList.index++;
        
        closeList.Add(ceap_path_info);
        
        int r_up = up_index + 1;
        int l_up = up_index - 1;
        int r_down = down_index + 1;
        int l_down = down_index - 1;   
        index = ceap_path_info.Index;     
    }
    
    int count_close_list = closeList.index;
    for(int i = 0; i < count_close_list; ++i)
    {
        PathBuffer[closeList.buffer[i].Index].CostToGoal = closeList.buffer[i].Cost;
    }
    PathBuffer[GoalIndex].CostToGoal = 10;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{    
    NumHeight = 100;    
    
    //thread id to index
    uint index = GetIndex(id);
    
    //get calc index
    //int index_to_calc = CalcPathBuffer[ index];
    PathInfo pathInfo = PathBuffer[index];
    //PathFind(PlayerIndex);        
    PathFind(PlayerIndex);
    
}
